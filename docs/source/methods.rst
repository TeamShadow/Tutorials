Methods-------Another key concept to Shadow is methods. In simple terms, a method is a body of code (enclosed in ``{ }``) with a defined purpose. Methods make *source code* more readable and concise, as it breaks it up into separate “chunks.” In fact, most code is contained inside of methods.Whether you noticed it or not, we have already been doing our coding inside of a method: the ``main`` method (for more information, see a previous section, “The ``main`` Method"). However, as our programs get more and more complex, writing numerous loops and doing numerous calculations all inside the ``main`` method can make the code hard to decipher, and very inefficient. Thus, we create other methods.Before we break down all the components of a method, take a look at the following program that will guide our analysis. .. code-block:: shadow    :linenos: 		import shadow:io@Console;	class Method2	{		/* Imagine you are at a restaurant with 3 other friends. 		* The service was amazing, so you want to leave a 30% tip. 		* Then, you would like to split the total dining cost 		* plus tip evenly between the four of you. 		* The following program introduces methods to accomplish 		* these tasks. 		*/		public main( String[] args ) => () //the main method 		{			var mealCost = 90.56; 			var tipPercent = 30; 			var people = 4; 					//Two example method calls are below			var includeTip = calculateTip(mealCost, tipPercent);					Console.print("The price per person is: " # perPerson(mealCost + includeTip, people)); 			}			// The two methods we will discuss are below			public calculateTip(double price, double percent) => (double)		{				var tip = price * (percent/100); 			return tip; 		}			public perPerson(double price, int numPeople) => (double)		{			return price/numPeople; 		}	}	The console output is as follows: .. code-block:: console     The price per person is: 29.432	Method Headers ^^^^^^^^^^^^^^^First, we will break down method headers and signatures. **Lines 12, 27, and 33** are the three method headers (with signatures) in the program. We are going to focus on the ones in **Line 27** and **Line 33**. ``public calculateTip(double price, double percent) => (double)````public perPerson(double price, int numPeople) => (double)``Each of these statements is called a **method header**. As we go over each word in the headers, it is important to recognize that no matter what method you are writing, the order of each element **cannot change**. **The Access Modifier** The first thing we should notice is the reserved word ``public``. For now, until we get to “Classes in Shadow”, we will start all methods with the **access modifier** ``public`` (versus ``private``). If a variable or a method is declared ``public`` this means that there are no restrictions on who can access/use/change it. **The Method Name** The next element we see is the  **method name**.  The same rules apply for method names as variable names. The convention is to use CamelCase notation, with the first word always lower case. Your method name should also be descriptive of its purpose; someone else reading your code should have a general idea what the method does just from the title. For example,  you can assume ``calculateTip``  probably calculates the amount of tip you should leave for a given meal cost. **The Parameter List**The list of variables inside of the parentheses are called **parameters**.  A method may take in no parameters, one parameter, or many parameters. It is up to the programmer to decide.  In general, a parameter is a value passed to a method when the method is called. The method header specifies the type and order of each value that must be passed in for the method to execute. For example,  the parameters for ``perPerson`` are ``double price`` and ``int numPeople``. This means that when the method is called  (which will be discussed in this section), the first value  must be a ``double`` and the second value must be an ``int``. Then, inside of the method, ``price`` and ``numPeople`` become local variables and are initialized to the values passed in. **Return Type**The last element in the **method header** is the **return type**, which specifies the value that is in essence “sent back” to the method where the call was made. The general syntax is ``=> (type)``. The type could be in an ``int``, ``double``, ``String``, ``code``, array, object, etc. The programmer defines it. In our example, both ``calculateTip`` and ``inPerson`` have a ``double`` return type. This means that if you tried to return a ``String`` instead of a ``double``, you will get a compile error. As seen in **Lines 30 and 35**, a ``return`` statement starts with the reserved word ``return`` and is followed by either a variable name, literal value, or some expression that results in the appropriate type. Do not forget the semicolon at the end. .. note:: A method does not need to have a return type. It could simply peform some action, or call another method. No matter the reason, when there is no return type, simply leave the parentheses empty.The Method Body^^^^^^^^^^^^^^^Now that you understand the basic elements of a method header, let’s briefly discuss the method body -- the code enclosed in ``{ }`` following the method header. Within the method body you may do a number of things, including but limited to: calling another method, performing calculations, creating an array, initializing an object, and printing statements to the console. In other words, this is where the execution of a method’s purpose takes place. If the method has a specified return type, it must have a return statement at the end of the method body, or the program will not compile. Conversely, if there is no return type, the method should not try to return a value. Calling a method^^^^^^^^^^^^^^^^At this point, we have established how to write a basic method that returns one value. Now, we will examine how to call a method using the example from the beginning. But first, let’s define what we mean by *calling a method*: Until we cover Classes in Shadow, let’s assume we are calling our methods from the ``main`` method. This is where the program “starts.” As seen in **Lines 14-16**, the first lines in the ``main`` method, we have a couple of variables with initial values. Now, we want to use the method ``calculateTip``. How? We write a **method call.** In order to call a method, the syntax is: ``methodName(parameter, parameter, etc.)``. This can also be seen in **Lines 19 and 21**. You may be wondering why we stored the result of one method call in a variable, and used the other in a ``Console.printLine()``. Both are syntactically correct, but they serve different purposes. We stored the ``double`` value **returned** from the ``calculateTip`` method in ``includeTip`` so that we could use this variable as a parameter for the other method. Once we call ``perPerson`` we are done doing calculations, so there wasn’t a need to store the result in a variable before printing it out. **In summary**,  if a method returns some value and you don’t either store it in a variable or “do something” with it, you are not able to go back to “retrieve” that value later in the program. Once the program reaches a return statement, control is passed back to the calling method (in this case, the ``main`` method). However, if your method  *does not* return anything, there is no value to be dealt with, and the statements inside the method body are executed before control is returned to the ``main`` method. Method Signatures and Overloaded Methods^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Within the method header, there is something called the **method signature**. The method signature consists of the method’s name and parameter list. In the previous example, the method signature of ``calculateTip`` would be ``calculateTip(double price, double percent)``.Why is the method signature important? It helps us recognize when there is **method overloading**. In basic terms, **method overloading** happens when you have more than one method of the same name, but *different parameter lists*. In order to be considered different parameter lists, the types and/or number of parameters must be changed. Each method is essentially a variation of the other. The following short program is an example of method overloading. .. code-block:: shadow    :linenos: 		import shadow:io@Console;	class OverloadedMethod	{		public main( String[] args ) => () 		{			playLottery(8); 			Console.printLine(); 			playLottery(10, "Daily Double"); 				}					public playLottery(int num) => ()		{			Console.printLine("Jackpot! You just won " # num # " dollars!");			}			public playLottery(int num, String name) => ()		{			Console.printLine("You're playing the " # name # "!"); 			Console.printLine("Jackpot! You just won " # num # " dollars!"); 		}		}		The console produces the following message: .. code-block:: console 	Jackpot! You just won 8 dollars!	You're playing the Daily Double!	Jackpot! You just won 10 dollars!Notice how in **Lines 7 and 9**, we make a method to call ``playLottery``. But if there are two methods named ``playLottery``, who do we know which one will run?  Let’s start with **Line 7**. The program knows to run the first ``playLottery`` method (starting on **Line 13**), as its parameter list of one ``int``  matches this method’s parameter list in type and number. This is different than **Line 9**, where the method call has *two* parameters, an ``int`` and a ``String``. The program then knows to run the second method, as their parameters “match”. Thus, ``playLottery`` is an overloaded method. Although this can be a useful programming concept to know, it can also become confusing which method will actually run, so practice overloading methods sparingly. Returning Multiple Values^^^^^^^^^^^^^^^^^^^^^^^^^ A unique, and very useful, feature of **Shadow** is the ability to return multiple values from a method. All the same principles discussed above still apply; all you need to learn is the syntax, which is best illustrated through an example: .. code-block:: shadow    :linenos: 	public main( String[] args ) => () 	{		int result, modulus, answer; 		(result, modulus) = divide(7, 3); 		(answer, ) = divide(7, 3); 				Console.printLine("result is " # result # " and modulus is " # modulus); 		Console.printLine("answer is " # answer); 	}		public divide(int a, int b) => (int, int)	{		int quotient = a / b;		int remainder = a % b;		return (quotient, remainder);	}	The console output is: .. code-block:: console 	result is 2 and modulus is 1	answer is 2	As seen in **Line 4**, in order to store both values returned by ``divide`` into variables in the ``main`` method, the syntax is ``(variable1, variable 2) = methodCall(parameters);`` Note that in **Line 5**, we left out the second return value. It is perfectly acceptable to do this. Simply leave a blank space for whichever value you are choosing to ignore. .. note:: The order of the values that you are returning should match the order of the variables you are setting these values equal to. For example, if the first return value of a method is a ``String`` and the second is a ``double``, putting a ``double`` variable first instead of a ``String`` variable will cause a compile error. A Note on Scope^^^^^^^^^^^^^^^The last topic to discuss relating to methods is **scope**. The term scope was first defined in the ``for`` Loops section, and is basically where a variable carries meaning in a program. For example, a counter variable that is declared inside of a ``for`` loop has a scope inside the loop itself. It cannot be accessed outside of the loop. The same concept applies to **parameters.** Let’s say I have a method called ``doCoolStuff``, and in the ``main`` method I have two variables: ``String word = "pecan pie"; double number = 3.14;``The method header for ``doCoolStuff`` is: ``public doCoolStuff(String word, double number) => ( String )`` Are the parameters ``word`` and ``number`` the same as the variables ``word`` and ``number`` in the main method? **No**.  *Primitive type parameters are not passed by reference. They are passed by* **value.**  In other words, if you change the value of ``word`` in ``doCoolStuff`` to "apple pie", **the variable** ``word`` in the ``main`` method still equals "pecan pie".  The parameters act as local variables whose scope is within the method that they are defined. This is why it is not always a good idea to name the parameter the same as local variables in other methods. It can be tricky to determine which is being changed or referenced. 		